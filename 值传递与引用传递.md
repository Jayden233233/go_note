关于值传递、指针传递、引用传递的思考。

摘要：本篇文章对比java、go、还有C++中的传递方式，来弄清楚值传递、指针传递、引用传递这几个概念。以及该要怎么描述不同语言中的传递方式，才不会出现歧义。很多人会迷惑有时候说java中只有值传递，有些地方又说java中的引用类型是引用传递。其实我觉得两种说法都对，只是大家在讨论的时候把不同立场的概念杂糅在一起了，导致话术上出现了歧义。



为了弄明白值传递、指针传递、引用传递的本质，我们从C++这个语言来进行切入，从C++的角度来理解这三种传递很多问题就会迎刃而解。

先参考这篇文章：https://zhuanlan.zhihu.com/p/351097872，我把核心结论摘录到下一小段中。

> C++函数的三种传递方式为：[值传递](https://zhida.zhihu.com/search?content_id=166152074&content_type=Article&match_order=1&q=值传递&zhida_source=entity)、[指针传递](https://zhida.zhihu.com/search?content_id=166152074&content_type=Article&match_order=1&q=指针传递&zhida_source=entity)和[引用传递](https://zhida.zhihu.com/search?content_id=166152074&content_type=Article&match_order=1&q=引用传递&zhida_source=entity)。
>
> 指针/引用传递的格式，可以参考以下的内容：
>
> ```cpp
> int x=1;
> 
> int *y=&x; //用于指针传递，y有自己独立的内存地址，存储的内容是x的地址，*y是x的值
> 
> int &z=x; //用于引用传递，可以理解为z就是x，x就是z，只不过名字不一样
> ```



另外C++ 中的**指针传递本质上是值传递**。

 **指针传递的本质是值传递**

- **值传递的定义**：函数接收的是实参的**副本**，对副本的修改不会影响原始值。

- **指针传递的实现**：

- - 实参是一个**地址值**（指针）。

- - 函数接收的是该地址值的**副本**（即复制了指针，但两个指针指向同一内存地址）。

- - **关键点**：虽然指针副本和原始指针指向同一内存地址，但它们是两个独立的变量（存储在不同内存位置）。

**示例**：

```
void modify(int* ptr) {
    *ptr = 100;     // 修改指针所指的值（影响原始数据）
    ptr = nullptr;  // 修改指针副本（不影响原始指针）
}

int main() {
    int x = 10;
    int* px = &x;
    modify(px);     // 传递指针的副本
    cout << *px;    // 输出：100（值被修改）
    cout << (px == nullptr);  // 输出：0（原始指针未被设为nullptr）
}
```



**所以我们可以得出以下的结论：**

当和其他人讨论某某语言是值传递还是引用传递时？最好的回答：

1.要先明确值传递和引用传递的具体是怎么定义的，在概念定义好后，后续的讨论才不会有歧义。

2.不要从**行为方式**的角度来定义值传递和引用传递，**即，不要把形参能否对方法外的实参造成影响作为区分的标准**。

3.应该从**内存空间**的角度定义值传递和引用传递，**即，我们要观测在内存中是否为形参开辟了新的空间。**形参开辟了新空间就是值传递（pass by value），形参未开辟新空间就是引用传递（pass by reference）。

值传递（Pass by Value）根据传递内容可分为：
1. **传递基本类型值**：如 C++ `int x`、Java `int a`。**Pass by Value**
2. **传递指针值**：如 C++ `int* ptr`（复制指针变量的地址）。**pass by pointer**
3. **传递引用值**：如 Java 对象引用、Go 切片（复制对象/切片的地址或结构体）。**pass by value of reference** 或自定义一个概念**pass by value of struct**

引用传递（Pass by Reference）：仅 C++ `int& ref`（形参是实参的别名，无内存复制）。

4.易混淆的概念： 引用类型的传递不是引用传递，而是pass by value of reference

5.[golang中结构体当做函数参数或函数返回值都会被拷贝](https://www.cnblogs.com/mayanan/p/15413647.html)

#### **跨语言传递方式的标准化描述**

| 语言 | 传递方式                         | 示例                               | 内存行为（是否开辟新空间） |
| ---- | -------------------------------- | ---------------------------------- | -------------------------- |
| C++  | 值传递                           | `func(int x)`                      | 是（复制值）               |
|      | 值传递（指针类型（值传递特例）） | `func(int* ptr)`                   | 是（复制指针地址）         |
|      | 引用传递                         | `func(int& ref)`                   | 否（共享内存）             |
| Java | 值传递（基本类型）               | `void func(int i)`                 | 是（复制值）               |
|      | 值传递（引用类型）               | `void func(Object obj)`            | 是（复制对象引用地址）     |
| Go   | 值传递（基本类型）               | `func(x int)`                      | 是（复制值）               |
|      | 值传递（结构体 / 切片）          | `func(s struct)` / `func(s []int)` | 是（复制结构体 / 切片头）  |
